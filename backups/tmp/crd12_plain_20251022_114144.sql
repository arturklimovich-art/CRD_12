--
-- PostgreSQL database dump
--

\restrict cwsgp18ayG1xFbTz2jPbbPN05VZBICv6uj4i4ue0N42Ag0vrcpxq3KtmMZoUxbz

-- Dumped from database version 16.10 (Debian 16.10-1.pgdg12+1)
-- Dumped by pg_dump version 16.10 (Debian 16.10-1.pgdg12+1)

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

SET default_tablespace = '';

SET default_table_access_method = heap;

--
-- Name: tasks; Type: TABLE; Schema: public; Owner: crd_user
--

CREATE TABLE public.tasks (
    id integer NOT NULL,
    user_id character varying(64) NOT NULL,
    task_description text NOT NULL,
    status character varying(32) NOT NULL,
    error_message text,
    created_at timestamp without time zone NOT NULL,
    started_at timestamp without time zone,
    completed_at timestamp without time zone,
    updated_at timestamp without time zone NOT NULL,
    generated_code text,
    test_results jsonb,
    deployment_ready boolean NOT NULL
);


ALTER TABLE public.tasks OWNER TO crd_user;

--
-- Name: tasks_id_seq; Type: SEQUENCE; Schema: public; Owner: crd_user
--

CREATE SEQUENCE public.tasks_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE public.tasks_id_seq OWNER TO crd_user;

--
-- Name: tasks_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: crd_user
--

ALTER SEQUENCE public.tasks_id_seq OWNED BY public.tasks.id;


--
-- Name: tasks id; Type: DEFAULT; Schema: public; Owner: crd_user
--

ALTER TABLE ONLY public.tasks ALTER COLUMN id SET DEFAULT nextval('public.tasks_id_seq'::regclass);


--
-- Data for Name: tasks; Type: TABLE DATA; Schema: public; Owner: crd_user
--

COPY public.tasks (id, user_id, task_description, status, error_message, created_at, started_at, completed_at, updated_at, generated_code, test_results, deployment_ready) FROM stdin;
1	388536051	Создай функцию для вычисления площади круга	completed	\N	2025-10-22 08:36:33.42211	2025-10-22 08:36:33.486325	2025-10-22 08:36:48.044277	2025-10-22 06:36:33.425462	import math\n\ndef calculate_circle_area(radius):\n    """\n    Вычисляет площадь круга по заданному радиусу.\n    \n    Args:\n        radius (float): Радиус круга\n        \n    Returns:\n        float: Площадь круга\n        \n    Raises:\n        ValueError: Если радиус отрицательный\n    """\n    if radius < 0:\n        raise ValueError("Радиус не может быть отрицательным")\n    \n    return math.pi * radius ** 2\n\ndef main(radius):\n    """\n    Основная функция для вычисления площади круга.\n    \n    Args:\n        radius (float): Радиус круга\n        \n    Returns:\n        float: Площадь круга\n    """\n    return calculate_circle_area(radius)\n\n# Пример использования\nif __name__ == "__main__":\n    # Тестирование функции\n    test_radii = [1, 5, 10, 2.5]\n    for r in test_radii:\n        area = main(r)\n        print(f"Площадь круга с радиусом {r} = {area:.2f}")	"{\\"status\\": \\"ok\\", \\"tests_status\\": \\"passed\\", \\"smoke_message\\": \\"OK: 3.141592653589793\\", \\"started\\": \\"2025-10-22T06:36:33.498960\\", \\"finished\\": \\"2025-10-22T06:36:48.041621\\", \\"llm_report\\": {\\"status\\": \\"ok\\", \\"tests\\": {\\"unit\\": \\"skipped\\"}, \\"notes\\": \\"Создана функция calculate_circle_area() для вычисления площади круга по формуле πr². Основная функция main() принимает радиус и возвращает площадь. Добавлена проверка на отрицательный радиус и обработка ошибок.\\"}}"	f
2	388536051	Создай функцию для вычисления площади круга	completed	\N	2025-10-22 08:52:38.417288	2025-10-22 08:52:38.552257	2025-10-22 08:52:47.87302	2025-10-22 06:52:38.419248	import math\n\ndef main(radius):\n    """\n    Вычисляет площадь круга по заданному радиусу.\n    \n    Args:\n        radius (float): Радиус круга\n        \n    Returns:\n        float: Площадь круга\n    """\n    if radius < 0:\n        raise ValueError("Радиус не может быть отрицательным")\n    \n    area = math.pi * radius ** 2\n    return area\n\n# Пример использования\nif __name__ == "__main__":\n    # Тестирование функции\n    test_radius = 5.0\n    result = main(test_radius)\n    print(f"Площадь круга с радиусом {test_radius} равна: {result:.2f}")	"{\\"status\\": \\"ok\\", \\"tests_status\\": \\"passed\\", \\"smoke_message\\": \\"OK: 3.141592653589793\\", \\"started\\": \\"2025-10-22T06:52:38.561247\\", \\"finished\\": \\"2025-10-22T06:52:47.870085\\", \\"llm_report\\": {\\"status\\": \\"ok\\", \\"tests\\": {\\"unit\\": \\"skipped\\"}, \\"notes\\": \\"Создана функция main(radius), которая вычисляет площадь круга по формуле πr². Добавлена проверка на отрицательный радиус. Использована библиотека math для получения точного значения π.\\"}}"	f
3	388536051	Создай функцию для вычисления площади круга	completed	\N	2025-10-22 08:58:37.133316	2025-10-22 08:58:37.230167	2025-10-22 08:58:46.878739	2025-10-22 06:58:37.135801	import math\n\ndef main(radius):\n    """\n    Вычисляет площадь круга по заданному радиусу.\n    \n    Args:\n        radius (float): Радиус круга\n        \n    Returns:\n        float: Площадь круга\n    """\n    if radius < 0:\n        raise ValueError("Радиус не может быть отрицательным")\n    \n    area = math.pi * radius ** 2\n    return area\n\n# Пример использования\nif __name__ == "__main__":\n    # Тестирование функции\n    test_radius = 5.0\n    result = main(test_radius)\n    print(f"Площадь круга с радиусом {test_radius} равна: {result:.2f}")	"{\\"status\\": \\"ok\\", \\"tests_status\\": \\"passed\\", \\"smoke_message\\": \\"OK: 3.141592653589793\\", \\"started\\": \\"2025-10-22T06:58:37.237193\\", \\"finished\\": \\"2025-10-22T06:58:46.875853\\", \\"llm_report\\": {\\"status\\": \\"ok\\", \\"tests\\": {\\"unit\\": \\"skipped\\"}, \\"notes\\": \\"Создана функция main(radius), которая вычисляет площадь круга по формуле π*r². Добавлена проверка на отрицательный радиус. Использована библиотека math для получения точного значения π.\\"}}"	f
4	388536051	Создай функцию для вычисления площади круга	completed	\N	2025-10-22 09:17:52.863906	2025-10-22 09:17:52.945409	2025-10-22 09:18:07.174357	2025-10-22 07:17:52.867363	import math\n\ndef calculate_circle_area(radius):\n    """\n    Вычисляет площадь круга по заданному радиусу.\n    \n    Args:\n        radius (float): Радиус круга\n        \n    Returns:\n        float: Площадь круга\n        \n    Raises:\n        ValueError: Если радиус отрицательный\n    """\n    if radius < 0:\n        raise ValueError("Радиус не может быть отрицательным")\n    \n    return math.pi * radius ** 2\n\ndef main(radius):\n    """\n    Основная функция для вычисления площади круга.\n    \n    Args:\n        radius (float): Радиус круга\n        \n    Returns:\n        float: Площадь круга\n    """\n    return calculate_circle_area(radius)\n\n# Пример использования\nif __name__ == "__main__":\n    # Тестирование функции\n    test_radius = 5.0\n    area = main(test_radius)\n    print(f"Площадь круга с радиусом {test_radius} равна: {area:.2f}")\n    \n    # Дополнительные примеры\n    print(f"Площадь круга с радиусом 1: {main(1):.2f}")\n    print(f"Площадь круга с радиусом 2.5: {main(2.5):.2f}")	"{\\"status\\": \\"ok\\", \\"tests_status\\": \\"passed\\", \\"smoke_message\\": \\"OK: 3.141592653589793\\", \\"started\\": \\"2025-10-22T07:17:52.954637\\", \\"finished\\": \\"2025-10-22T07:18:07.171158\\", \\"llm_report\\": {\\"status\\": \\"ok\\", \\"tests\\": {\\"unit\\": \\"skipped\\"}, \\"notes\\": \\"Создана функция calculate_circle_area() для вычисления площади круга по формуле πr². Основная функция main() принимает радиус и возвращает площадь. Добавлена проверка на отрицательный радиус и обработка ошибок.\\"}}"	f
5	388536051	Создай функцию для вычисления площади круга	completed	\N	2025-10-22 09:28:04.165661	2025-10-22 09:28:04.322448	2025-10-22 09:28:19.913982	2025-10-22 07:28:04.168822	import math\n\ndef calculate_circle_area(radius):\n    """\n    Вычисляет площадь круга по заданному радиусу.\n    \n    Args:\n        radius (float): Радиус круга\n        \n    Returns:\n        float: Площадь круга\n        \n    Raises:\n        ValueError: Если радиус отрицательный\n    """\n    if radius < 0:\n        raise ValueError("Радиус не может быть отрицательным")\n    \n    return math.pi * radius ** 2\n\ndef main(radius):\n    """\n    Основная функция для вычисления площади круга.\n    \n    Args:\n        radius (float): Радиус круга\n        \n    Returns:\n        float: Площадь круга\n    """\n    return calculate_circle_area(radius)\n\n# Пример использования\nif __name__ == "__main__":\n    # Тестирование функции\n    test_radius = 5.0\n    area = main(test_radius)\n    print(f"Площадь круга с радиусом {test_radius} равна: {area:.2f}")\n    \n    # Дополнительные тесты\n    test_cases = [1.0, 2.5, 0, 10.0]\n    for r in test_cases:\n        try:\n            result = main(r)\n            print(f"Радиус: {r}, Площадь: {result:.2f}")\n        except ValueError as e:\n            print(f"Ошибка для радиуса {r}: {e}")	"{\\"status\\": \\"ok\\", \\"tests_status\\": \\"passed\\", \\"smoke_message\\": \\"OK: 3.141592653589793\\", \\"started\\": \\"2025-10-22T07:28:04.330450\\", \\"finished\\": \\"2025-10-22T07:28:19.910264\\", \\"llm_report\\": {\\"status\\": \\"ok\\", \\"tests\\": {\\"unit\\": \\"skipped\\"}, \\"notes\\": \\"Создана функция calculate_circle_area() для вычисления площади круга по формуле πr². Основная функция main() принимает радиус и возвращает площадь. Добавлена проверка на отрицательный радиус и обработка ошибок.\\"}}"	f
6	388536051	Напиши функцию sum_two_numbers(a, b), которая возвращает сумму двух чисел.	completed	\N	2025-10-22 09:48:14.504557	2025-10-22 09:48:14.590442	2025-10-22 09:48:23.288925	2025-10-22 07:48:14.506184	def main():\n    def sum_two_numbers(a, b):\n        return a + b\n    \n    # Примеры использования\n    result1 = sum_two_numbers(5, 3)\n    result2 = sum_two_numbers(-2, 7)\n    result3 = sum_two_numbers(0, 0)\n    \n    print(f"5 + 3 = {result1}")\n    print(f"-2 + 7 = {result2}")\n    print(f"0 + 0 = {result3}")\n    \n    return result1\n\nif __name__ == "__main__":\n    main()	"{\\"status\\": \\"ok\\", \\"tests_status\\": \\"passed\\", \\"smoke_message\\": \\"OK: 8\\", \\"started\\": \\"2025-10-22T07:48:14.601630\\", \\"finished\\": \\"2025-10-22T07:48:23.285854\\", \\"llm_report\\": {\\"status\\": \\"ok\\", \\"tests\\": {\\"unit\\": \\"skipped\\"}, \\"notes\\": \\"Создана функция sum_two_numbers, которая принимает два числа и возвращает их сумму. Функция main() демонстрирует работу функции на нескольких примерах и возвращает результат первого вычисления.\\"}}"	f
7	388536051	Напиши функцию sum_two_numbers(a, b), которая возвращает сумму двух чисел.	completed	\N	2025-10-22 09:54:04.230228	2025-10-22 09:54:04.310708	2025-10-22 09:54:11.836374	2025-10-22 07:54:04.235006	def sum_two_numbers(a, b):\n    """Возвращает сумму двух чисел."""\n    return a + b\n\ndef main(a, b):\n    """Основная функция входа, которая возвращает сумму двух чисел."""\n    return sum_two_numbers(a, b)\n\n# Пример использования\nif __name__ == "__main__":\n    result = main(5, 3)\n    print(f"Сумма чисел: {result}")	"{\\"status\\": \\"ok\\", \\"tests_status\\": \\"passed\\", \\"smoke_message\\": \\"OK: 2\\", \\"started\\": \\"2025-10-22T07:54:04.319921\\", \\"finished\\": \\"2025-10-22T07:54:11.833693\\", \\"llm_report\\": {\\"status\\": \\"ok\\", \\"tests\\": {\\"unit\\": \\"skipped\\"}, \\"notes\\": \\"Создана функция sum_two_numbers(a, b), которая возвращает сумму двух чисел через оператор +. Функция main(a, b) вызывает sum_two_numbers и возвращает результат.\\"}}"	t
8	388536051	Напиши функцию sum_two_numbers(a, b), которая возвращает сумму двух чисел.	completed	\N	2025-10-22 09:56:24.122774	2025-10-22 09:56:24.264729	2025-10-22 09:56:32.742192	2025-10-22 07:56:24.126714	def main():\n    def sum_two_numbers(a, b):\n        return a + b\n    \n    # Примеры использования\n    result1 = sum_two_numbers(5, 3)\n    result2 = sum_two_numbers(-2, 7)\n    result3 = sum_two_numbers(0, 0)\n    \n    # Возвращаем результаты для демонстрации\n    return {\n        "example1": result1,\n        "example2": result2, \n        "example3": result3\n    }\n\nif __name__ == "__main__":\n    results = main()\n    print(results)	"{\\"status\\": \\"ok\\", \\"tests_status\\": \\"passed\\", \\"smoke_message\\": \\"OK: {'example1': 8, 'example2': 5, 'example3': 0}\\", \\"started\\": \\"2025-10-22T07:56:24.273005\\", \\"finished\\": \\"2025-10-22T07:56:32.738985\\", \\"llm_report\\": {\\"status\\": \\"ok\\", \\"tests\\": {\\"unit\\": \\"skipped\\"}, \\"notes\\": \\"Создана функция sum_two_numbers(a, b), которая возвращает сумму двух чисел. Добавлены примеры использования для демонстрации работы функции.\\"}}"	t
9	388536051	Напиши функцию sum_two_numbers(a, b), которая возвращает сумму двух чисел.	completed	\N	2025-10-22 10:00:41.526239	2025-10-22 10:00:41.607414	2025-10-22 10:00:48.215458	2025-10-22 08:00:41.530162	def main():\n    def sum_two_numbers(a, b):\n        return a + b\n    \n    # Пример использования\n    result = sum_two_numbers(5, 3)\n    return result\n\nif __name__ == "__main__":\n    result = main()\n    print(f"Результат: {result}")	"{\\"status\\": \\"ok\\", \\"tests_status\\": \\"passed\\", \\"smoke_message\\": \\"OK: 8\\", \\"started\\": \\"2025-10-22T08:00:41.616517\\", \\"finished\\": \\"2025-10-22T08:00:48.212663\\", \\"llm_report\\": {\\"status\\": \\"ok\\", \\"tests\\": {\\"unit\\": \\"skipped\\"}, \\"notes\\": \\"Создана функция sum_two_numbers, которая принимает два числа и возвращает их сумму. Функция реализована через простое сложение параметров. В функции main() приведен пример использования.\\"}}"	t
10	388536051	Напиши функцию sum_two_numbers(a, b), которая возвращает сумму двух чисел.	completed	\N	2025-10-22 10:08:46.313371	2025-10-22 10:08:46.383753	2025-10-22 10:08:54.481882	2025-10-22 08:08:46.317317	def main(a, b):\n    """\n    Основная функция, которая возвращает сумму двух чисел.\n    \n    Args:\n        a: Первое число\n        b: Второе число\n    \n    Returns:\n        Сумма чисел a и b\n    """\n    def sum_two_numbers(x, y):\n        """Возвращает сумму двух чисел."""\n        return x + y\n    \n    return sum_two_numbers(a, b)\n\n# Пример использования\nif __name__ == "__main__":\n    result = main(5, 3)\n    print(f"Сумма чисел: {result}")	"{\\"status\\": \\"ok\\", \\"tests_status\\": \\"passed\\", \\"smoke_message\\": \\"OK: 2\\", \\"started\\": \\"2025-10-22T08:08:46.391616\\", \\"finished\\": \\"2025-10-22T08:08:54.478904\\", \\"llm_report\\": {\\"status\\": \\"ok\\", \\"tests\\": {\\"unit\\": \\"skipped\\"}, \\"notes\\": \\"Создана функция sum_two_numbers внутри main, которая возвращает сумму двух чисел. Основная функция main принимает параметры и возвращает результат вызова sum_two_numbers.\\"}}"	t
11	388536051	ПРОАНАЛИЗИРУЙ существующую систему и СОСТАВЬ план интеграции:\n\nСУЩЕСТВУЮЩИЕ КОМПОНЕНТЫ:\n- Bot (Telegram) - прием задач\n- Task Manager - оркестратор  \n- Engineer B API - ИИ-ядро с Intelligent Agent\n- DeepSeek Proxy - генерация кода\n- PostgreSQL - хранилище\n\nЗАДАЧА: Интегрировать в систему самостроительства с навигатором прогресса.\n\nСОСТАВЬ:\n1. Анализ текущих возможностей системы\n2. Список недостающих компонентов для самостроительства\n3. Конкретный план первых 10 маленьких шагов\n4. Оценку сложности каждого шага	completed	\N	2025-10-22 11:16:30.334989	2025-10-22 11:16:30.573011	2025-10-22 11:17:46.079269	2025-10-22 09:16:30.348947	import json\nfrom dataclasses import dataclass\nfrom typing import List, Dict, Any\nfrom enum import Enum\n\nclass ComplexityLevel(Enum):\n    LOW = "low"\n    MEDIUM = "medium"\n    HIGH = "high"\n\n@dataclass\nclass IntegrationStep:\n    step_number: int\n    description: str\n    complexity: ComplexityLevel\n    components_involved: List[str]\n    expected_outcome: str\n\nclass SystemAnalyzer:\n    def __init__(self):\n        self.existing_components = {\n            "Bot (Telegram)": "Прием задач от пользователей",\n            "Task Manager": "Оркестрация процессов и задач",\n            "Engineer B API": "ИИ-ядро с Intelligent Agent для анализа и принятия решений",\n            "DeepSeek Proxy": "Генерация кода и технических решений",\n            "PostgreSQL": "Хранение данных, состояний и истории"\n        }\n        \n        self.current_capabilities = self._analyze_current_capabilities()\n        self.missing_components = self._identify_missing_components()\n        self.integration_plan = self._create_integration_plan()\n\n    def _analyze_current_capabilities(self) -> Dict[str, List[str]]:\n        """Анализ текущих возможностей системы"""\n        return {\n            "communication": [\n                "Прием задач через Telegram бота",\n                "Взаимодействие между компонентами через API"\n            ],\n            "ai_capabilities": [\n                "Анализ задач Intelligent Agent",\n                "Генерация кода через DeepSeek",\n                "Принятие решений Engineer B"\n            ],\n            "data_management": [\n                "Хранение данных в PostgreSQL",\n                "Оркестрация задач Task Manager"\n            ],\n            "limitations": [\n                "Отсутствует система отслеживания прогресса",\n                "Нет механизма самоулучшения системы",\n                "Отсутствует навигатор развития",\n                "Нет метрик для оценки эффективности"\n            ]\n        }\n\n    def _identify_missing_components(self) -> List[Dict[str, str]]:\n        """Определение недостающих компонентов для самостроительства"""\n        return [\n            {\n                "component": "Progress Navigator",\n                "purpose": "Отслеживание прогресса системы и навигация по этапам развития",\n                "features": ["Визуализация прогресса", "Рекомендации по улучшению", "Метрики эффективности"]\n            },\n            {\n                "component": "Self-Improvement Engine",\n                "purpose": "Автоматическое улучшение системы на основе анализа результатов",\n                "features": ["Анализ успешных решений", "Оптимизация процессов", "Обучение на ошибках"]\n            },\n            {\n                "component": "Metrics Collector",\n                "purpose": "Сбор и анализ метрик производительности системы",\n                "features": ["Сбор статистики", "Анализ эффективности", "Выявление узких мест"]\n            },\n            {\n                "component": "Goal Management System",\n                "purpose": "Управление целями развития и приоритизация задач",\n                "features": ["Определение целей", "Приоритизация задач", "Оценка достижений"]\n            },\n            {\n                "component": "Adaptive Architecture Controller",\n                "purpose": "Динамическая адаптация архитектуры под новые требования",\n                "features": ["Рефакторинг компонентов", "Оптимизация связей", "Масштабирование системы"]\n            }\n        ]\n\n    def _create_integration_plan(self) -> List[IntegrationStep]:\n        """Создание плана интеграции из 10 маленьких шагов"""\n        return [\n            IntegrationStep(\n                step_number=1,\n                description="Добавить таблицу progress_tracking в PostgreSQL для хранения метрик прогресса",\n                complexity=ComplexityLevel.LOW,\n                components_involved=["PostgreSQL", "Task Manager"],\n                expected_outcome="База данных готова к сбору метрик прогресса"\n            ),\n            IntegrationStep(\n                step_number=2,\n                description="Создать API эндпоинты для записи и чтения метрик прогресса",\n                complexity=ComplexityLevel.MEDIUM,\n                components_involved=["Engineer B API", "PostgreSQL"],\n                expected_outcome="Система может сохранять и получать данные о прогрессе"\n            ),\n            IntegrationStep(\n                step_number=3,\n                description="Интегрировать сбор базовых метрик в Task Manager",\n                complexity=ComplexityLevel.MEDIUM,\n                components_involved=["Task Manager", "PostgreSQL"],\n                expected_outcome="Автоматический сбор метрик выполнения задач"\n            ),\n            IntegrationStep(\n                step_number=4,\n                description="Разработать модуль анализа эффективности в Engineer B API",\n                complexity=ComplexityLevel.HIGH,\n                components_involved=["Engineer B API", "PostgreSQL"],\n                expected_outcome="ИИ-система анализирует эффективность и выдает рекомендации"\n            ),\n            IntegrationStep(\n                step_number=5,\n                description="Создать Progress Navigator API для визуализации прогресса",\n                complexity=ComplexityLevel.MEDIUM,\n                components_involved=["Engineer B API", "PostgreSQL"],\n                expected_outcome="API для получения структурированных данных о прогрессе"\n            ),\n            IntegrationStep(\n                step_number=6,\n                description="Интегрировать Progress Navigator с Telegram ботом",\n                complexity=ComplexityLevel.MEDIUM,\n                components_involved=["Bot (Telegram)", "Engineer B API"],\n                expected_outcome="Пользователи видят прогресс через бота"\n            ),\n            IntegrationStep(\n                step_number=7,\n                description="Реализовать систему целей и KPI в Goal Management System",\n                complexity=ComplexityLevel.HIGH,\n                components_involved=["Engineer B API", "PostgreSQL", "Task Manager"],\n                expected_outcome="Система умеет ставить и отслеживать цели развития"\n            ),\n            IntegrationStep(\n                step_number=8,\n                description="Добавить механизм самоанализа в Self-Improvement Engine",\n                complexity=ComplexityLevel.HIGH,\n                components_involved=["Engineer B API", "DeepSeek Proxy"],\n                expected_outcome="Система анализирует свои слабые места и генерирует улучшения"\n            ),\n            IntegrationStep(\n                step_number=9,\n                description="Интегрировать Adaptive Architecture Controller",\n                complexity=ComplexityLevel.HIGH,\n                components_involved=["Task Manager", "Engineer B API", "DeepSeek Proxy"],\n                expected_outcome="Система может предлагать оптимизации архитектуры"\n            ),\n            IntegrationStep(\n                step_number=10,\n                description="Создать единый дашборд прогресса и рекомендаций",\n                complexity=ComplexityLevel.MEDIUM,\n                components_involved=["Bot (Telegram)", "Engineer B API", "PostgreSQL"],\n                expected_outcome="Полная система самостроительства с навигатором прогресса"\n            )\n        ]\n\n    def generate_analysis_report(self) -> Dict[str, Any]:\n        """Генерация полного отчета анализа"""\n        return {\n            "current_system_analysis": self.current_capabilities,\n            "missing_components": self.missing_components,\n            "integration_plan": [\n                {\n                    "step": step.step_number,\n                    "description": step.description,\n                    "complexity": step.complexity.value,\n                    "components": step.components_involved,\n                    "expected_outcome": step.expected_outcome\n                }\n                for step in self.integration_plan\n            ],\n            "summary": {\n                "total_steps": len(self.integration_plan),\n                "low_complexity_steps": len([s for s in self.integration_plan if s.complexity == ComplexityLevel.LOW]),\n                "medium_complexity_steps": len([s for s in self.integration_plan if s.complexity == ComplexityLevel.MEDIUM]),\n                "high_complexity_steps": len([s for s in self.integration_plan if s.complexity == ComplexityLevel.HIGH]),\n                "estimated_timeline_weeks": 12\n            }\n        }\n\ndef main(analysis_type: str = "full") -> Dict[str, Any]:\n    """\n    Основная функция анализа системы и создания плана интеграции\n    \n    Args:\n        analysis_type: Тип анализа ("full", "quick", "detailed")\n    \n    Returns:\n        Dict с полным отчетом анализа\n    """\n    analyzer = SystemAnalyzer()\n    \n    if analysis_type == "quick":\n        return {\n            "missing_components_count": len(analyzer.missing_components),\n            "integration_steps_count": len(analyzer.integration_plan),\n            "estimated_timeline_weeks": 12\n        }\n    elif analysis_type == "detailed":\n        return analyzer.generate_analysis_report()\n    else:\n        return analyzer.generate_analysis_report()\n\nif __name__ == "__main__":\n    # Пример использования\n    result = main("full")\n    print("Анализ системы завершен. Отчет сгенерирован.")	"{\\"status\\": \\"ok\\", \\"tests_status\\": \\"passed\\", \\"smoke_message\\": \\"OK: {'current_system_analysis': {'communication': ['Прием задач через Telegram бота', 'Взаимодействие между компонентами через API'], 'ai_capabilities': ['Анализ задач Intelligent Agent', 'Генерация кода через DeepSeek', 'Принятие решений Engineer B'], 'data_management': ['Хранение данных в PostgreSQL', 'Оркестрация задач Task Manager'], 'limitations': ['Отсутствует система отслеживания прогресса', 'Нет механизма самоулучшения системы', 'Отсутствует навигатор развития', 'Нет метрик для оценки эффективности']}, 'missing_components': [{'component': 'Progress Navigator', 'purpose': 'Отслеживание прогресса системы и навигация по этапам развития', 'features': ['Визуализация прогресса', 'Рекомендации по улучшению', 'Метрики эффективности']}, {'component': 'Self-Improvement Engine', 'purpose': 'Автоматическое улучшение системы на основе анализа результатов', 'features': ['Анализ успешных решений', 'Оптимизация процессов', 'Обучение на ошибках']}, {'component': 'Metrics Collector', 'purpose': 'Сбор и анализ метрик производительности системы', 'features': ['Сбор статистики', 'Анализ эффективности', 'Выявление узких мест']}, {'component': 'Goal Management System', 'purpose': 'Управление целями развития и приоритизация задач', 'features': ['Определение целей', 'Приоритизация задач', 'Оценка достижений']}, {'component': 'Adaptive Architecture Controller', 'purpose': 'Динамическая адаптация архитектуры под новые требования', 'features': ['Рефакторинг компонентов', 'Оптимизация связей', 'Масштабирование системы']}], 'integration_plan': [{'step': 1, 'description': 'Добавить таблицу progress_tracking в PostgreSQL для хранения метрик прогресса', 'complexity': 'low', 'components': ['PostgreSQL', 'Task Manager'], 'expected_outcome': 'База данных готова к сбору метрик прогресса'}, {'step': 2, 'description': 'Создать API эндпоинты для записи и чтения метрик прогресса', 'complexity': 'medium', 'components': ['Engineer B API', 'PostgreSQL'], 'expected_outcome': 'Система может сохранять и получать данные о прогрессе'}, {'step': 3, 'description': 'Интегрировать сбор базовых метрик в Task Manager', 'complexity': 'medium', 'components': ['Task Manager', 'PostgreSQL'], 'expected_outcome': 'Автоматический сбор метрик выполнения задач'}, {'step': 4, 'description': 'Разработать модуль анализа эффективности в Engineer B API', 'complexity': 'high', 'components': ['Engineer B API', 'PostgreSQL'], 'expected_outcome': 'ИИ-система анализирует эффективность и выдает рекомендации'}, {'step': 5, 'description': 'Создать Progress Navigator API для визуализации прогресса', 'complexity': 'medium', 'components': ['Engineer B API', 'PostgreSQL'], 'expected_outcome': 'API для получения структурированных данных о прогрессе'}, {'step': 6, 'description': 'Интегрировать Progress Navigator с Telegram ботом', 'complexity': 'medium', 'components': ['Bot (Telegram)', 'Engineer B API'], 'expected_outcome': 'Пользователи видят прогресс через бота'}, {'step': 7, 'description': 'Реализовать систему целей и KPI в Goal Management System', 'complexity': 'high', 'components': ['Engineer B API', 'PostgreSQL', 'Task Manager'], 'expected_outcome': 'Система умеет ставить и отслеживать цели развития'}, {'step': 8, 'description': 'Добавить механизм самоанализа в Self-Improvement Engine', 'complexity': 'high', 'components': ['Engineer B API', 'DeepSeek Proxy'], 'expected_outcome': 'Система анализирует свои слабые места и генерирует улучшения'}, {'step': 9, 'description': 'Интегрировать Adaptive Architecture Controller', 'complexity': 'high', 'components': ['Task Manager', 'Engineer B API', 'DeepSeek Proxy'], 'expected_outcome': 'Система может предлагать оптимизации архитектуры'}, {'step': 10, 'description': 'Создать единый дашборд прогресса и рекомендаций', 'complexity': 'medium', 'components': ['Bot (Telegram)', 'Engineer B API', 'PostgreSQL'], 'expected_outcome': 'Полная система самостроительства с навигатором прогресса'}], 'summary': {'total_steps': 10, 'low_complexity_steps': 1, 'medium_complexity_steps': 5, 'high_complexity_steps': 4, 'estimated_timeline_weeks': 12}}\\", \\"started\\": \\"2025-10-22T09:16:30.597379\\", \\"finished\\": \\"2025-10-22T09:17:46.074049\\"}"	t
12	388536051	docker compose logs bot --tail=20	completed	\N	2025-10-22 11:18:10.095742	2025-10-22 11:18:10.186861	2025-10-22 11:18:27.597335	2025-10-22 09:18:10.096445	import subprocess\nimport sys\n\ndef main(service_name="bot", tail_lines=20):\n    """\n    Получает последние логи из docker-compose для указанного сервиса\n    \n    Args:\n        service_name (str): имя сервиса (по умолчанию "bot")\n        tail_lines (int): количество последних строк логов (по умолчанию 20)\n    \n    Returns:\n        str: вывод команды docker compose logs или сообщение об ошибке\n    """\n    try:\n        # Формируем команду\n        cmd = ["docker", "compose", "logs", "--tail", str(tail_lines), service_name]\n        \n        # Выполняем команду и захватываем вывод\n        result = subprocess.run(\n            cmd,\n            capture_output=True,\n            text=True,\n            check=True\n        )\n        \n        return result.stdout\n        \n    except subprocess.CalledProcessError as e:\n        return f"Ошибка выполнения команды: {e.stderr}"\n    except FileNotFoundError:\n        return "Ошибка: docker compose не найден. Убедитесь, что Docker установлен и доступен."\n    except Exception as e:\n        return f"Неожиданная ошибка: {str(e)}"\n\nif __name__ == "__main__":\n    # Получаем аргументы командной строки если они есть\n    service = sys.argv[1] if len(sys.argv) > 1 else "bot"\n    tail = int(sys.argv[2]) if len(sys.argv) > 2 else 20\n    \n    # Выполняем и выводим результат\n    output = main(service, tail)\n    print(output)	"{\\"status\\": \\"error\\", \\"tests_status\\": \\"failed\\", \\"smoke_message\\": \\"Ошибка выполнения основной функции: invalid literal for int() with base 10: '--host'\\", \\"started\\": \\"2025-10-22T09:18:10.193650\\", \\"finished\\": \\"2025-10-22T09:18:27.594310\\", \\"llm_report\\": {\\"status\\": \\"ok\\", \\"tests\\": {\\"unit\\": \\"skipped\\"}, \\"notes\\": \\"Решение использует subprocess для выполнения команды docker compose logs с параметрами --tail. Функция main принимает имя сервиса и количество строк, обрабатывает ошибки и возвращает результат. Код готов к использованию и включает обработку основных ошибок.\\"}}"	f
\.


--
-- Name: tasks_id_seq; Type: SEQUENCE SET; Schema: public; Owner: crd_user
--

SELECT pg_catalog.setval('public.tasks_id_seq', 12, true);


--
-- Name: tasks tasks_pkey; Type: CONSTRAINT; Schema: public; Owner: crd_user
--

ALTER TABLE ONLY public.tasks
    ADD CONSTRAINT tasks_pkey PRIMARY KEY (id);


--
-- Name: ix_tasks_id; Type: INDEX; Schema: public; Owner: crd_user
--

CREATE INDEX ix_tasks_id ON public.tasks USING btree (id);


--
-- Name: ix_tasks_status; Type: INDEX; Schema: public; Owner: crd_user
--

CREATE INDEX ix_tasks_status ON public.tasks USING btree (status);


--
-- Name: ix_tasks_user_id; Type: INDEX; Schema: public; Owner: crd_user
--

CREATE INDEX ix_tasks_user_id ON public.tasks USING btree (user_id);


--
-- PostgreSQL database dump complete
--

\unrestrict cwsgp18ayG1xFbTz2jPbbPN05VZBICv6uj4i4ue0N42Ag0vrcpxq3KtmMZoUxbz

