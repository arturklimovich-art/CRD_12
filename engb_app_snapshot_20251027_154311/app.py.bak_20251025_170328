# # -*- coding: utf-8 -*-
from fastapi import FastAPI, HTTPException
from datetime import datetime
import logging
from typing import Any, Dict, Optional, Tuple
import os
import json
import asyncio  # оставлено для совместимости, может использоваться в будущем
import httpx    # оставлено для совместимости, может использоваться в будущем
import re       # парсинг ответов

# === S1-FIX-SELF-DEPLOY: Step 3 (imports) START ===
import subprocess  # Для запуска подпроцесса
import sys         # Для получения пути к python (sys.executable)
import tempfile    # Для временных файлов
import textwrap    # Для очистки отступов
import shutil      # Для move бэкапа (Step 4)
import signal      # S1-FIX-SELF-DEPLOY: Step 5 (SIGHUP супервизору)
# === S1-FIX-SELF-DEPLOY: Step 3 (imports) END ===

# Импорты из локальных модулей
# Важно: LLMRouter может иметь разные сигнатуры __init__, поэтому инициализацию делаем в startup с try/except.
from llm_router import LLMRouter
from intelligent_agent import IntelligentAgent, DeepSeekExecutor

# =============================================================================
# ГЛОБАЛЬНЫЕ НАСТРОЙКИ
# =============================================================================
# Было: INFO → стало: DEBUG + фиксированный формат; повышаем уровень именно для этого логгера
logging.basicConfig(level=logging.DEBUG, format="%(asctime)s - %(name)s - %(levelname)-8s - %(message)s")
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

# КОНФИГУРАЦИЯ
# Примечание: DeepSeekExecutor внутри сам защищён от двойного суффикса /llm/complete.
DEEPSEEK_URL = os.getenv("DEEPSEEK_PROXY_URL", "http://deepseek_proxy:8010/llm/complete").rstrip("/")
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
GEMINI_MODEL = os.getenv("GEMINI_MODEL", "gemini-1.5-pro")

# Корневой путь кода внутри контейнера (см. bind-mount в docker-compose)
APP_ROOT_PATH = "/app"

# Регэксп для извлечения пути файла из ТЗ (поддержка Modify/Patch/Edit/Fix ...)
_FILEPATH_RE = re.compile(r"(?:Modify|Patch|Edit|Fix)\s+([\w\./\-_]+\.py)", re.IGNORECASE)

app = FastAPI(title="Engineer B API", version="4.0 - Self-Healing")

agent: Optional[IntelligentAgent] = None
llm_router: Optional[LLMRouter] = None
deepseek_executor: Optional[DeepSeekExecutor] = None

# =============================================================================
# ВСПОМОГАТЕЛЬНЫЕ ПАРСЕРЫ
# =============================================================================
_CODE_FENCE = re.compile(r"```(?:python|py)?\s*(?P<code>[\s\S]*?)\s*```", re.IGNORECASE | re.DOTALL)
_JSON_FENCE = re.compile(r"```json\s*(?P<json>[\s\S]*?\})\s*```", re.IGNORECASE | re.DOTALL)
_AUTO_REPORT = re.compile(r"===\s*АВТОНОМНЫЙ ОТЧЁТ\s*===.*?```json\s*(\{[\s\S]*?\})\s*```", re.IGNORECASE | re.DOTALL)

def _extract_code(text: str) -> str:
    """
    Достаём код из ```python-блока. Если внутри JSON — игнорируем.
    """
    m = _CODE_FENCE.search(text or "")
    if not m:
        return ""
    s = (m.group("code") or "").strip()
    # если LLM ошибся и положил JSON в python-блок — отбрасываем
    if s.startswith("{") and s.endswith("}"):
        return ""
    return s

def _extract_report_json(text: str) -> Dict[str, Any]:
    """
    Ищем итоговый отчёт:
      1) приоритетно — внутри блока с маркером "=== АВТОНОМНЫЙ ОТЧЁТ ==="
      2) иначе — первый ```json ... ```
    """
    m = _AUTO_REPORT.search(text or "")
    raw = None
    if m:
        raw = m.group(1).strip()
    else:
        j = _JSON_FENCE.search(text or "")
        raw = j.group("json").strip() if j else None

    if not raw:
        return {
            "deployment_ready": False,
            "description": "Could not find final report block in LLM response.",
            "tests_status": "error",
        }
    try:
        return json.loads(raw)
    except json.JSONDecodeError as e:
        logger.warning("❌ Failed to parse report JSON: %s", e)
        return {
            "deployment_ready": False,
            "description": "Could not parse report JSON from LLM response.",
            "tests_status": "error",
        }

# --- помощник для проверки принадлежности пути к /app ---
def _under_app_root(path: str) -> bool:
    try:
        if not path:
            return False
        rp = os.path.realpath(path)
        rr = os.path.realpath(APP_ROOT_PATH)
        return rp == rr or rp.startswith(rr + os.sep)
    except Exception:
        return False

# =============================================================================
# S1-FIX-SELF-DEPLOY · Step 3 — Runtime-Smoke (подпроцесс)
# =============================================================================
# === S1-FIX-SELF-DEPLOY: Step 3 START ===
def _run_runtime_smoke_test(code_str: str, target_filepath: Optional[str]) -> Tuple[bool, str]:
    """
    Выполняет runtime-smoke тест в отдельном подпроцессе.
    1) Создаёт временный .py-файл с dedent'нутым кодом (убираем лишние отступы/вставки).
    2) Запускает его как скрипт через текущий интерпретатор (sys.executable).
    3) При ненулевом exit-code — возвращает (False, stderr/код).
    4) Если модифицируем app.py — дополнительно проверяет, что в неймспейсе есть 'app'.
    Возвращает (ok, message).
    """
    if not code_str:
        return False, "Runtime Smoke: Code is empty."

    logger.info("[Runtime Smoke] Starting test in subprocess...")
    tmp_filepath = None
    try:
        with tempfile.NamedTemporaryFile(mode="w", suffix=".py", delete=False, encoding='utf-8') as tmp_file:
            # Убираем внешние отступы и возможный BOM
            dedented_code = textwrap.dedent(code_str).lstrip('\ufeff')
            tmp_file.write(dedented_code)
            tmp_filepath = tmp_file.name

        # Команда для запуска Python-интерпретатора с нашим временным файлом
        cmd = [sys.executable, tmp_filepath]
        logger.debug("[Runtime Smoke] Executing command: %s", " ".join(cmd))

        # Запускаем подпроцесс с таймаутом (15 секунд)
        process = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            encoding='utf-8',
            errors='replace',  # игнорируем/заменяем ошибки декодирования вывода
            timeout=15,
            check=False  # не выбрасывать исключение при ненулевом коде возврата
        )

        stdout = (process.stdout or "").strip()
        stderr = (process.stderr or "").strip()
        exit_code = process.returncode

        logger.debug("[Runtime Smoke] Subprocess finished. Exit code: %d", exit_code)
        if stdout:
            logger.debug("[Runtime Smoke] Subprocess stdout:\n%s", stdout[:500])
        if stderr:
            logger.debug("[Runtime Smoke] Subprocess stderr:\n%s", stderr[:500])

        if exit_code != 0:
            error_msg = f"Runtime Smoke Failed: Subprocess exited with code {exit_code}."
            if stderr:
                error_msg += f" Stderr: {stderr[:300]}"
            logger.warning(error_msg)
            return False, error_msg
        else:
            # Дополнительная проверка, если меняем app.py (загружаем неймспейс)
            is_app_py = bool(target_filepath) and (os.path.basename(target_filepath) == "app.py")
            if is_app_py:
                logger.debug("[Runtime Smoke] Target is app.py, checking namespace...")
                try:
                    import runpy
                    ns = runpy.run_path(tmp_filepath)
                    if "app" not in ns:
                        logger.error("[Runtime Smoke] CRITICAL: 'app' attribute missing after modifying app.py!")
                        return False, "Runtime Smoke Failed: Generated code modified app.py but removed the 'app' FastAPI instance."
                    else:
                        logger.info("[Runtime Smoke] 'app' attribute check passed for app.py modification.")
                except Exception as ns_err:
                    logger.error("[Runtime Smoke] Failed to check namespace for app.py: %s", ns_err)
                    return False, f"Runtime Smoke Failed: Namespace check error for app.py - {ns_err}"

            logger.info("[Runtime Smoke] Test passed.")
            return True, "Runtime Smoke OK"

    except subprocess.TimeoutExpired:
        logger.warning("[Runtime Smoke] Test timed out after 15s.")
        return False, "Runtime Smoke Failed: Test execution timed out."
    except Exception as e:
        logger.exception("[Runtime Smoke] Unexpected error during test.")
        return False, f"Runtime Smoke Failed: Unexpected error - {type(e).__name__}: {e}"
    finally:
        # Удаляем временный файл
        if tmp_filepath and os.path.exists(tmp_filepath):
            try:
                os.remove(tmp_filepath)
                logger.debug("[Runtime Smoke] Cleaned up temp file: %s", tmp_filepath)
            except Exception as e_clean:
                logger.warning("[Runtime Smoke] Failed to clean up temp file %s: %s", tmp_filepath, e_clean)
# === S1-FIX-SELF-DEPLOY: Step 3 END ===

# =============================================================================
# ПРИМЕНЕНИЕ ПАТЧЕЙ (САМОИЗМЕНЕНИЕ)
# =============================================================================
def _get_target_filepath(task_text: str) -> Optional[str]:
    """
    Извлекает путь к файлу из ТЗ и преобразует его в абсолютный путь внутри контейнера.
    Пример ТЗ: "Modify src/app/engineer_b_api/intelligent_agent.py to..."
    """
    match = _FILEPATH_RE.search(task_text or "")
    if not match:
        logger.info('Auto-applying code regardless of path detection')
        return None

    relative_path = match.group(1).replace("\\", "/")
    logger.info(f"Found relative path in prompt: {relative_path}")

    # Преобразуем ожидаемый путь вида 'src/app/engineer_b_api/...' в '/app/...'
    if relative_path.startswith("src/app/engineer_b_api/"):
        file_name = relative_path.replace("src/app/engineer_b_api/", "", 1)
        container_path = os.path.join(APP_ROOT_PATH, file_name)
        safe_path = os.path.normpath(container_path)
        logger.info(f"Mapped to container path: {safe_path}")
        return safe_path

    # === PATCH B START ===
    # Голые имена основных файлов внутри контейнера
    if relative_path in {"app.py", "intelligent_agent.py", "llm_router.py", "tools.py"}:
        safe_path = os.path.normpath(os.path.join(APP_ROOT_PATH, relative_path))
        logger.info(f"Mapped known filename to container path: {safe_path}")
        return safe_path
    # Явные /app/ пути (с проверкой корня)
    if relative_path.startswith("/app/"):
        safe_path = os.path.normpath(relative_path)
        if safe_path == APP_ROOT_PATH or safe_path.startswith(APP_ROOT_PATH + os.sep):
            logger.info(f"Using absolute container path: {safe_path}")
            return safe_path
    # === PATCH B END ===

    logger.warning(
        f"Path {relative_path} is not recognized for this agent. "
        f"Expected 'src/app/engineer_b_api/...', '/app/...', or a known filename."
    )
    return None

# === S1-FIX-SELF-DEPLOY: Step 4 START ===
def _apply_code_changes(filepath: str, code: str) -> Tuple[bool, str]:
    """
    АТОМАРНО применяет код к файлу:
    1. Создает .bak копию (уникальное имя с датой/временем).
    2. Пишет код во временный файл в той же директории.
    3. Использует os.replace() для атомарной замены.
    4. Пытается откатить из .bak при любой ошибке.
    """
    safe_path = os.path.normpath(filepath)
    # Защита от записи вне корня приложения (остается)
    if not (safe_path == APP_ROOT_PATH or safe_path.startswith(APP_ROOT_PATH + os.sep)):
        logger.error("❌ SECURITY ERROR: Attempted to write outside of %s: %s", APP_ROOT_PATH, safe_path)
        return False, f"SECURITY ERROR: Path {safe_path} is outside the {APP_ROOT_PATH} directory."

    backup_path = f"{safe_path}.bak_{datetime.now().strftime('%Y%m%d_%H%M%S')}"  # Уникальное имя бэкапа
    temp_filepath = ""  # имя временного файла (инициализация)
    file_dir = os.path.dirname(safe_path) or "."

    try:
        # 1. Создаем бэкап (если файл существует)
        if os.path.exists(safe_path):
            # В одной директории это будет переименование (атомарно на типичных FS)
            shutil.move(safe_path, backup_path)
            logger.info("Created unique backup: %s", backup_path)
        else:
            logger.info("Target file %s does not exist, creating new.", safe_path)
            # Убедимся, что директория существует
            os.makedirs(file_dir, exist_ok=True)

        # 2. Пишем во временный файл В ТОЙ ЖЕ ДИРЕКТОРИИ, что и цель
        # Это важно для атомарности os.replace() на большинстве ФС
        with tempfile.NamedTemporaryFile(mode="w", suffix=".tmp", dir=file_dir, delete=False, encoding='utf-8') as tmp_file:
            temp_filepath = tmp_file.name
            logger.debug("Writing code to temporary file: %s", temp_filepath)
            tmp_file.write(code)
            # Важно: убедиться, что данные записаны на диск перед replace
            tmp_file.flush()
            os.fsync(tmp_file.fileno())

        # 3. Атомарно заменяем старый файл (или создаем новый) временным
        logger.debug("Atomically replacing %s with %s", safe_path, temp_filepath)
        os.replace(temp_filepath, safe_path)  # атомарная операция

        # Дополнительно: fsync директории для гарантии видимости файла (особенно на Linux)
        try:
            dir_fd = os.open(file_dir, os.O_RDONLY)
            try:
                os.fsync(dir_fd)
            finally:
                os.close(dir_fd)
        except OSError as fsync_err:
            # Не критично, если fsync директории не удался, но логируем
            logger.warning("Could not fsync directory %s: %s", file_dir, fsync_err)

        logger.info("✅ Successfully applied ATOMIC code changes to %s", safe_path)
        return True, f"Atomically applied patch to {safe_path}"

    except Exception as e:
        logger.exception("❌ FAILED to apply ATOMIC code changes to %s: %s", safe_path, e)
        # Пытаемся откатить из бэкапа
        try:
            if os.path.exists(backup_path):
                # Если целевой файл уже существует (частично создан/заменен), удалим его перед откатом
                if os.path.exists(safe_path):
                    try:
                        os.remove(safe_path)
                    except Exception as rm_err:
                        logger.warning("Could not remove %s before rollback: %s", safe_path, rm_err)
                # Восстанавливаем бэкап
                os.rename(backup_path, safe_path)  # rename для отката
                logger.warning("Restored %s from unique backup %s.", safe_path, backup_path)
            # Если бэкапа не было, а целевой файл создался — удаляем его
            elif os.path.exists(safe_path):
                try:
                    os.remove(safe_path)
                    logger.warning("Removed partially created file %s during rollback.", safe_path)
                except Exception as rm2_err:
                    logger.error("Failed to remove partially created file %s: %s", safe_path, rm2_err)
        except Exception as e_restore:
            logger.error("❌ CRITICAL: Failed to restore from backup %s: %s", backup_path, e_restore)
        return False, f"Failed to write file atomically: {e}"
    finally:
        # Удаляем временный файл, если он остался
        if temp_filepath and os.path.exists(temp_filepath):
            try:
                os.remove(temp_filepath)
                logger.debug("Cleaned up temp file: %s", temp_filepath)
            except Exception as e_clean:
                logger.warning("Failed to clean up temp file %s: %s", temp_filepath, e_clean)
# === S1-FIX-SELF-DEPLOY: Step 4 END ===

# =============================================================================
# ФУНКЦИИ ЖИЗНЕННОГО ЦИКЛА (STARTUP & SHUTDOWN)
# =============================================================================
@app.on_event("startup")
async def startup_event():
    global llm_router, agent, deepseek_executor

    # === S1-FIX-SELF-DEPLOY: Step 1 START (CODE_PATH_MARKER) ===
    try:
        import importlib
        from importlib.util import find_spec
        import intelligent_agent as _ia

        agent_path = os.path.realpath(getattr(_ia, "__file__", "") or "")
        app_path = os.path.realpath(__file__)

        logger.info("CODE_PATH_MARKER: app.py = %s", app_path)
        logger.info("CODE_PATH_MARKER: intelligent_agent.py = %s", agent_path)

        spec = find_spec("intelligent_agent")
        if spec and getattr(spec, "origin", None):
            logger.debug("CODE_PATH_MARKER: intelligent_agent.spec.origin = %s",
                         os.path.realpath(spec.origin))

        if not _under_app_root(agent_path):
            logger.error("CRITICAL ERROR: intelligent_agent loaded outside %s → %s",
                         APP_ROOT_PATH, agent_path)
        if not _under_app_root(app_path):
            logger.error("CRITICAL ERROR: app.py loaded outside %s → %s",
                         APP_ROOT_PATH, app_path)
    except Exception as e:
        logger.error("CRITICAL ERROR during CODE_PATH_MARKER check: %s", e)
    # === S1-FIX-SELF-DEPLOY: Step 1 END ===

    # Инициализация состояния приложения
    app.state.start_time = datetime.now()
    app.state.analysis_history = []
    app.state.ready = False  # readiness флаг по умолчанию

    # 1) LLMRouter (Gemini) — «мягкая» инициализация без падения при несовместимой сигнатуре
    try:
        llm_router = None
        try:
            # Современная сигнатура некоторых реализаций
            llm_router = LLMRouter(gemini_api_key=GEMINI_API_KEY, gemini_model_name=GEMINI_MODEL)  # type: ignore[call-arg]
            logger.info("✅ LLMRouter (Gemini) initialized with gemini_api_key/model.")
        except TypeError as te:
            logger.warning("⚠️ LLMRouter(gemini_api_key=...) unsupported: %s. Try default ctor.", te)
            try:
                # Старые версии — без параметров
                llm_router = LLMRouter()  # type: ignore[call-arg]
                logger.info("✅ LLMRouter (Gemini) initialized with default ctor.")
            except Exception as e2:
                logger.warning("⚠️ LLMRouter default ctor failed: %s. Running without Gemini.", e2)
                llm_router = None
    except Exception as e:
        logger.warning("⚠️ LLMRouter initialization failed: %s. Running without Gemini.", e)
        llm_router = None

    # 2) DeepSeekExecutor
    deepseek_executor = DeepSeekExecutor(api_url=DEEPSEEK_URL, api_key="")
    logger.info("✅ DeepSeekExecutor initialized (url=%s)", DEEPSEEK_URL)

    # 3) IntelligentAgent (совместим и с router=..., и с llm_router=...)
    try:
        agent = IntelligentAgent(llm_router=llm_router, deepseek_executor=deepseek_executor)
        logger.info("✅ IntelligentAgent initialized successfully")
        app.state.ready = True
    except Exception as e:
        agent = None
        app.state.ready = False
        logger.error("❌ IntelligentAgent initialization failed: %s", e)

    logger.info("🚀 Engineer B API fully initialized")

@app.on_event("shutdown")
async def shutdown_event():
    logger.info("🛑 Shutting down Engineer B API...")
    if deepseek_executor and getattr(deepseek_executor, "client", None):
        try:
            await deepseek_executor.client.aclose()
            logger.info("✅ DeepSeekExecutor client closed.")
        except Exception as e:
            logger.warning("⚠️ Error on DeepSeekExecutor client close: %s", e)
    logger.info("👋 Engineer B API shutdown complete")

# =============================================================================
# ОСНОВНОЙ ЭНДПОИНТ АГЕНТА — ПРАВДИВЫЙ СТАТУС + САМОПРИМЕНЕНИЕ
# =============================================================================
@app.post("/agent/analyze")
async def analyze_task(task_data: Dict[str, Any]):
    """
    Принимает задачу, передает агенту, достаёт код и отчёт.
    Если SmokeTest пройден и в ТЗ указан целевой файл — применяет патч в /app.
    Возвращает *правдивый* статус для оркестратора.
    """
    if not app.state.ready or agent is None:
        raise HTTPException(status_code=503, detail="Agent not ready")

    user_prompt = (task_data or {}).get("task", "").strip()
    if not user_prompt:
        return {
            "status": "failed",
            "analysis": "Task prompt was empty, no action taken.",
            "is_complete": False,
            "generated_code": "",
            "report": {"deployment_ready": False, "description": "Empty task", "tests_status": "skipped"},
        }

    logger.info("📝 Received task: %s", user_prompt[:160])

    try:
        # Вызов агента (он же запускает SmokeTest)
        # Ожидаем dict: {"status": "ok"/"failed", "code": "...", "report": "...", "raw": "..."}
        analysis_result = await agent.run_cycle(user_prompt)
        # ↓↓↓ Шаг 93: глубокое логирование результата агента
        logger.debug(
            "Received analysis_result from agent.run_cycle (type %s): %s",
            type(analysis_result).__name__, analysis_result
        )

        # Базовые поля
        generated_code: str = ""
        report_data: Dict[str, Any] = {"deployment_ready": False, "description": "No report", "tests_status": "error"}
        analysis_text_for_debug: str = ""

        # Достаём "сырой" текст для диагностики
        if isinstance(analysis_result, dict):
            analysis_text_for_debug = analysis_result.get("raw") or ""
        else:
            analysis_text_for_debug = str(analysis_result)

        # Код
        if isinstance(analysis_result, dict):
            code_field = analysis_result.get("code") or ""
            if code_field:
                m = _CODE_FENCE.search(code_field)
                generated_code = (m.group("code") if m else code_field).strip()
            else:
                generated_code = _extract_code(analysis_text_for_debug)
        else:
            generated_code = _extract_code(analysis_text_for_debug)

        # Отчёт
        rep = None
        if isinstance(analysis_result, dict):
            rep = analysis_result.get("report")
        if isinstance(rep, dict):
            report_data = rep
        elif isinstance(rep, str):
            report_data = _extract_report_json(rep)
        else:
            report_data = _extract_report_json(analysis_text_for_debug or "")

        # ↓↓↓ Шаг 93: логируем извлечённые данные
        logger.debug("Extracted generated_code (first 200 chars): %s", (generated_code[:200] if generated_code else "None"))
        logger.debug("Extracted report_data: %s", report_data)

        # Правдивый статус от агента (результат SmokeTest)
        agent_status = (analysis_result.get("status") if isinstance(analysis_result, dict) else None) or "error"
        smoke_test_ok = (agent_status in ("ok", "passed", "success"))

        final_status_for_orchestrator = "failed"  # по умолчанию

        # ЛОГИКА ПРИНЯТИЯ РЕШЕНИЙ
        # === PATCH: Step 3 - Call Runtime Smoke Test START ===
        target_file = _get_target_filepath(user_prompt)  # Определяем цель ДО runtime smoke
        runtime_smoke_ok, runtime_smoke_msg = False, "Skipped (no code or agent failed)"
        if smoke_test_ok and generated_code:  # Только если синтакс-чек агента прошел
            runtime_smoke_ok, runtime_smoke_msg = _run_runtime_smoke_test(generated_code, target_file)
        # === PATCH: Step 3 - Call Runtime Smoke Test END ===

        # if smoke_test_ok and generated_code:  # Старая проверка
        if smoke_test_ok and runtime_smoke_ok and generated_code:  # НОВАЯ проверка (оба теста должны пройти)
            # Пройдены ОБА SmokeTest — можно применять
            if target_file:
                logger.info("Both smoke tests passed. Attempting to apply changes to: %s", target_file)
                applied_ok, apply_msg = _apply_code_changes(target_file, generated_code)

                if applied_ok:
                    final_status_for_orchestrator = "passed"
                    # === PATCH: Step 5 - Send SIGHUP START ===
                    try:
                        supervisor_pid = 1  # PID основного процесса в контейнере (Supervisor)
                        logger.info(f"Patch applied. Sending SIGHUP to Supervisor PID {supervisor_pid} for worker restart...")
                        os.kill(supervisor_pid, signal.SIGHUP)
                        logger.info("SIGHUP signal sent.")
                    except AttributeError:
                        logger.warning("SIGHUP signal not available on this platform (Windows?). Cannot trigger worker restart.")
                    except ProcessLookupError:
                        logger.error(f"Supervisor process with PID {supervisor_pid} not found!")
                    except Exception as sig_err:
                        logger.error(f"Failed to send SIGHUP signal: {sig_err}", exc_info=True)
                    # === PATCH: Step 5 - Send SIGHUP END ===
                    report_data["description"] = f"Patch successfully applied to {target_file}. {apply_msg}. Restart triggered."
                    report_data["tests_status"] = "passed"
                    report_data["deployment_ready"] = True
                    report_data["smoke_test_result"] = runtime_smoke_msg
                else:
                    final_status_for_orchestrator = "failed"
                    report_data["description"] = f"Smoke tests passed, but FAILED to apply patch: {apply_msg}"
                    report_data["tests_status"] = "error"
                    report_data["deployment_ready"] = False
                    report_data["smoke_test_result"] = runtime_smoke_msg
            else:
                # Оба SmokeTest пройдены, но прямого файла в ТЗ нет — возвращаем код
                logger.info("Both smoke tests passed, but no target file specified. Returning code.")
                final_status_for_orchestrator = "passed"
                report_data.setdefault("description", "Code generated and passed both smoke tests. No file modification requested.")
                report_data["deployment_ready"] = True  # Считаем готовым, т.к. код рабочий
                report_data.setdefault("tests_status", "passed")
                report_data["smoke_test_result"] = runtime_smoke_msg

        elif not generated_code:
            # Без изменений остальной логики — просто дополним отчёт полем smoke_test_result
            logger.warning("⚠️ No code extracted from agent response.")
            report_data.setdefault("description", "No code extracted from LLM response.")
            final_status_for_orchestrator = "failed"
            report_data["deployment_ready"] = False
            report_data["smoke_test_result"] = "No code extracted"
        else:
            # Один из SmokeTest провален
            fail_reason = runtime_smoke_msg if not runtime_smoke_ok else report_data.get('smoke_message', "Syntax check failed")
            logger.warning("Smoke test failed. Code not applied. Reason: %s", fail_reason)
            final_status_for_orchestrator = "failed"
            report_data.setdefault("description", f"Smoke test failed: {fail_reason}")
            report_data["deployment_ready"] = False
            report_data["smoke_test_result"] = fail_reason

        # Возвращаем правдивый ответ
        return {
            "status": final_status_for_orchestrator,
            "analysis": analysis_text_for_debug or (analysis_result if isinstance(analysis_result, str) else json.dumps(analysis_result, ensure_ascii=False)),
            "is_complete": (final_status_for_orchestrator == "passed") and bool(report_data.get("deployment_ready", False)),
            "generated_code": generated_code,
            "report": report_data,
        }

    except Exception as e:
        logger.exception("❌ Critical error during agent analysis: %s", e)
        error_report = {
            "deployment_ready": False,
            "description": f"Критический сбой во время анализа: {type(e).__name__}: {str(e)}",
            "tests_status": "error",
            "smoke_test_result": f"Internal Error: {type(e).__name__}",
        }
        return {
            "status": "error",
            "analysis": f"=== АВТОНОМНЫЙ ОТЧЁТ ===\n```json\n{json.dumps(error_report, ensure_ascii=False, indent=2)}\n```",
            "is_complete": False,
            "error": str(e),
            "generated_code": "",
            "report": error_report,
        }

# =============================================================================
# СИСТЕМНЫЕ ЭНДПОИНТЫ
# =============================================================================
@app.get("/")
async def root():
    return {
        "message": "Engineer B API is running",
        "version": "4.0",
        "status": "operational",
        "endpoints": {"health": "/system/health", "ready": "/ready", "memory": "/agent/memory", "analyze": "/agent/analyze (POST)"},
    }

@app.get("/system/health")
async def health_check():
    return {"status": "ok", "uptime": str(datetime.now() - app.state.start_time), "llm_router_active": llm_router is not None}

@app.get("/ready")
async def ready():
    if app.state.ready and agent is not None:
        return {"status": "ok"}
    raise HTTPException(status_code=503, detail="Agent not ready")

@app.get("/agent/memory")
async def get_agent_memory():
    if agent and hasattr(agent, "get_memory"):
        return agent.get_memory()
    raise HTTPException(status_code=503, detail="Agent is not initialized")

# === AutoDev startup marker (safe to keep) ===
try:
    from fastapi import FastAPI
    # если объект app уже существует, добавим startup-хук
    _app_obj = globals().get("app", None)
    if isinstance(_app_obj, FastAPI):
        @_app_obj.on_event("startup")
        async def _autodev_start_marker():
            import logging
            logging.getLogger("uvicorn.error").info("EngineerB START [MARK:ENGB-BOOT-1337]")
except Exception as _e:
    # не ломаем приложение при ошибках маркера
    pass
# === /marker ===

# === ENGINEER_B_MARKER ===
try:
    import logging
    logging.getLogger("uvicorn.error").info("EngineerB app loaded [MARK:ENGB-BOOT-1337]")
except Exception:
    pass
# === /ENGINEER_B_MARKER ===
print("EngineerB app loaded [MARK:ENGB-BOOT-PRINT]")

