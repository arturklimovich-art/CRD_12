# -*- coding: utf-8 -*-
from fastapi import FastAPI, Request
from fastapi.responses import HTMLResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from datetime import datetime
import logging
from typing import Any, Dict, Optional, Tuple
import os
import json
import asyncio
import httpx
import re
import subprocess
import sys
import tempfile
import textwrap
import shutil
import signal
import hashlib
import time
import importlib

# === ROADMAP MODULE INTEGRATION ===
print("[DEBUG] Starting Roadmap import...")
try:
    from routes.roadmap import router as roadmap_router
    ROADMAP_AVAILABLE = True
    print("[DEBUG] Roadmap import SUCCESS, ROADMAP_AVAILABLE=True")
except Exception as e_roadmap:
    print(f"[DEBUG] Exception during import: {e_roadmap}")
    ROADMAP_AVAILABLE = False


# === INTEGRATION: PatchManager for Self-Deploy ===
try:
    from patch_applier import apply_code_with_fallback
    PATCH_APPLIER_AVAILABLE = True
except Exception as e_patch:
    print(f"WARNING: PatchApplier not available: {e_patch}")
    PATCH_APPLIER_AVAILABLE = False

# === E1-B14.27: Import external runtime smoke test ===
# Предполагается, что run_runtime_smoke_test(generated_code, target_file, job_id=...) возвращает (bool, message)
try:
    from runtime_smoke import run_runtime_smoke_test
except Exception:
    def run_runtime_smoke_test(code: str, target_file: Optional[str], job_id: Optional[str] = None):
        # Фоллбек: сделать простую проверку синтаксиса
        try:
            compile(code, "<string>", "exec")
            return True, "Syntax OK (fallback)"
        except Exception as e:
            return False, f"Syntax error: {e}"

# === Шаг 7: события/артефакты — безопасные заглушки при недоступности core.event_bus ===
try:
    from core.event_bus import put_event, upload_artifact, sha256_str, ensure_events_table
except Exception:
    def put_event(*args, **kwargs):  # type: ignore
        return None
    def upload_artifact(*args, **kwargs):  # type: ignore
        return None
    def sha256_str(s: str) -> str:  # type: ignore
        return hashlib.sha256((s or "").encode("utf-8", "replace")).hexdigest()
    def ensure_events_table():  # type: ignore
        return None

# === [IDEMPOTENCY/LOCKS] Импорты с безопасным fallback ===
try:
    from locks import LockManager  # type: ignore
except Exception:  # безопасная in-memory заглушка
    class _LockToken:
        def __init__(self, key: str) -> None:
            self.key = key
    class _FallbackLockManager:
        def __init__(self) -> None:
            self._locks: Dict[str, int] = {}
        class _Ctx:
            def __init__(self, mgr: "_FallbackLockManager", key: str) -> None:
                self.mgr = mgr
                self.key = key
            async def __aenter__(self):
                while self.mgr._locks.get(self.key, 0) > 0:
                    await asyncio.sleep(0.01)
                self.mgr._locks[self.key] = 1
                return _LockToken(self.key)
            async def __aexit__(self, exc_type, exc, tb):
                try:
                    self.mgr._locks.pop(self.key, None)
                except Exception:
                    pass
        def acquire_lock(self, key: Optional[str]):
            return self._Ctx(self, key or "/app/.global")
    LockManager = _FallbackLockManager  # type: ignore

try:
    from idempotency import IdempotencyManager  # type: ignore
except Exception:
    class _FallbackIdempotencyManager:
        """Простая in-memory идемпотентность. В бою заменяется на версию с PostgreSQL (core.patches)."""
        def __init__(self) -> None:
            self._store: Dict[str, Dict[str, Any]] = {}
        async def get_existing_result(self, key: str) -> Optional[Dict[str, Any]]:
            return self._store.get(key)
        async def update_patch_status(self, key: str, status: str, result: Dict[str, Any]) -> None:
            self._store[key] = {"status": status, "result": result, "updated_at": datetime.utcnow().isoformat()}
    IdempotencyManager = _FallbackIdempotencyManager  # type: ignore

# Важное замечание: LLMRouter может отличаться по сигнатурой __init__
from llm_router import LLMRouter
from intelligent_agent import IntelligentAgent, DeepSeekExecutor
from curator import Curator

# =============================================================================
# Конфигурация логирования
# =============================================================================
logging.basicConfig(level=logging.DEBUG, format="%(asctime)s - %(name)s - %(levelname)-8s - %(message)s")
logger = logging.getLogger(__name__)
logger.setLevel(logging.DEBUG)

# Конфиг
DEEPSEEK_URL = os.getenv("DEEPSEEK_PROXY_URL", "http://deepseek_proxy:8010/llm/complete").rstrip("/")
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")
GEMINI_MODEL = os.getenv("GEMINI_MODEL", "gemini-1.5-pro")

# Единый корень кода рантайма
APP_ROOT_PATH = "/app"

# Детектор целевого файла из текста задачи
_FILEPATH_RE = re.compile(r"(?:Modify|Patch|Edit|Fix)\s+([\w\./\-_]+\.py)", re.IGNORECASE)

app = FastAPI(title="Engineer B API", version="4.1 - Self-Healing + Roadmap")

# === TEMPLATES AND STATIC FILES ===
templates = Jinja2Templates(directory="templates")
app.mount("/static", StaticFiles(directory="static"), name="static")


# Register Roadmap router
if ROADMAP_AVAILABLE:
    app.include_router(roadmap_router)

    # Roadmap HTML UI
    @app.get("/roadmap", response_class=HTMLResponse)
    async def roadmap_page(request: Request):
        """
        Roadmap Dashboard - Web UI
        
        ?????????? ????????????? dashboard ? ??????? ? ????????
        """
        return templates.TemplateResponse("roadmap.html", {
            "request": request,
            "title": "CRD12 Roadmap Dashboard"
        })
    print("✅ Roadmap router registered")


# === CODE_PATH_MARKER START ===
import sys as _sys
log = logging.getLogger(__name__)
try:
    import intelligent_agent as ia
    log.info("CODE_PATH_MARKER app=%s ia=%s SYSPATH_HEAD=%s", __file__, getattr(ia, "__file__", None), _sys.path[:4])
except Exception as e:
    log.warning("CODE_PATH_MARKER failed: %s", e)
# === CODE_PATH_MARKER END ===

agent: Optional[IntelligentAgent] = None
llm_router: Optional[LLMRouter] = None
deepseek_executor: Optional[DeepSeekExecutor] = None

# =============================================================================
# Утилиты и S1-FIX-SELF-DEPLOY helpers
# =============================================================================

def _under_app_root(path: str) -> bool:
    try:
        real = os.path.realpath(path or "")
        return real == APP_ROOT_PATH or real.startswith(os.path.join(APP_ROOT_PATH, ""))
    except Exception:
        return False

def generate_idempotency_key(target_file: Optional[str], code: str, prompt: str) -> str:
    key_raw = f"{target_file or ''}::{sha256_str(code)}::{sha256_str(prompt)}"
    return hashlib.sha256(key_raw.encode("utf-8")).hexdigest()

# Safety toggle for auto-apply when no explicit path is detected.
ALLOW_AUTO_APPLY_WHEN_NO_PATH = False

def _get_target_filepath(task_text: str) -> Optional[str]:
    match = _FILEPATH_RE.search(task_text or "")
    if not match:
        if ALLOW_AUTO_APPLY_WHEN_NO_PATH:
            logger.warning("ALLOW_AUTO_APPLY_WHEN_NO_PATH=True: proceeding without explicit target path. This is unsafe.")
            return None
        else:
            logger.warning("Refusing to auto-apply code: no target path detected; require explicit target_filepath or a verified Python code block in the LLM response.")
            return None
    relative_path = match.group(1).replace("\\", "/")
    logger.info(f"Found relative path in prompt: {relative_path}")
    if relative_path.startswith("src/app/engineer_b_api/"):
        file_name = relative_path.replace("src/app/engineer_b_api/", "", 1)
        container_path = os.path.join(APP_ROOT_PATH, file_name)
        safe_path = os.path.normpath(container_path)
        logger.info(f"Mapped to container path: {safe_path}")
        return safe_path
    logger.warning(f"Detected path outside allowed prefix: {relative_path}. Refusing to map/apply.")
    return None

# Atomic apply + backup logic (Step 4)
def _apply_code_changes(filepath: str, code: str) -> Tuple[bool, str, Optional[str]]:
    """
    Возвращает (success, message, backup_path)
    """
    safe_path = os.path.normpath(filepath)
    if not (safe_path == APP_ROOT_PATH or safe_path.startswith(APP_ROOT_PATH + os.sep)):
        logger.error("SECURITY ERROR: Attempted to write outside of %s: %s", APP_ROOT_PATH, safe_path)
        return False, f"SECURITY ERROR: Path {safe_path} is outside the {APP_ROOT_PATH} directory.", None
    backup_path = f"{safe_path}.bak_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
    temp_filepath = ""
    file_dir = os.path.dirname(safe_path) or "."
    try:
        old_hash = ""
        if os.path.exists(safe_path):
            with open(safe_path, "rb") as f:
                old_hash = hashlib.sha256(f.read()).hexdigest()
        new_hash = sha256_str(code)
        try:
            put_event(stage="patch", event_type="patch_write_started", context={"target_file": safe_path, "new_sha256": new_hash, "old_sha256": old_hash})
        except Exception:
            pass
    except Exception:
        pass
    try:
        if os.path.exists(safe_path):
            shutil.move(safe_path, backup_path)
            logger.info("Created unique backup: %s", backup_path)
        else:
            logger.info("Target file %s does not exist, creating new.", safe_path)
            os.makedirs(file_dir, exist_ok=True)
        with tempfile.NamedTemporaryFile(mode="w", suffix=".tmp", dir=file_dir, delete=False, encoding="utf-8") as tmp_file:
            temp_filepath = tmp_file.name
            logger.debug("Writing code to temporary file: %s", temp_filepath)
            tmp_file.write(code)
            tmp_file.flush()
            os.fsync(tmp_file.fileno())
        logger.debug("Atomically replacing %s with %s", safe_path, temp_filepath)
        os.replace(temp_filepath, safe_path)
        try:
            dir_fd = os.open(file_dir, os.O_RDONLY)
            try:
                os.fsync(dir_fd)
            finally:
                os.close(dir_fd)
        except OSError as fsync_err:
            logger.warning("Could not fsync directory %s: %s", file_dir, fsync_err)
        logger.info("Successfully applied ATOMIC code changes to %s", safe_path)
        try:
            put_event(stage="patch", event_type="patch_written", context={"target_file": safe_path, "backup_path": backup_path, "new_sha256": sha256_str(code)})
        except Exception:
            pass
        return True, f"Atomically applied patch to {safe_path}", backup_path
    except Exception as e:
        logger.exception("FAILED to apply ATOMIC code changes to %s: %s", safe_path, e)
        try:
            put_event(stage="patch", event_type="incident", context={"severity": "error", "message": f"apply failed: {e}", "target_file": safe_path})
        except Exception:
            pass
        try:
            if os.path.exists(backup_path):
                if os.path.exists(safe_path):
                    try:
                        os.remove(safe_path)
                    except Exception as rm_err:
                        logger.warning("Could not remove %s before rollback: %s", safe_path, rm_err)
                os.rename(backup_path, safe_path)
                try:
                    put_event(stage="rollback", event_type="rolled_back", context={"restored_from": backup_path, "target": safe_path})
                except Exception:
                    pass
                logger.warning("Restored %s from unique backup %s.", safe_path, backup_path)
            elif os.path.exists(safe_path):
                try:
                    os.remove(safe_path)
                    logger.warning("Removed partially created file %s during rollback.", safe_path)
                except Exception as rm2_err:
                    logger.error("Failed to remove partially created file %s: %s", safe_path, rm2_err)
        except Exception as e_restore:
            logger.error("CRITICAL: Failed to restore from backup %s: %s", backup_path, e_restore)
        return False, f"Failed to write file atomically: {e}", None
    finally:
        if temp_filepath and os.path.exists(temp_filepath):
            try:
                os.remove(temp_filepath)
                logger.debug("Cleaned up temp file: %s", temp_filepath)
            except Exception as e_clean:
                logger.warning("Failed to clean up temp file %s: %s", temp_filepath, e_clean)

# === New: wait for post-restart health + verification ===
async def _wait_for_post_restart(target_file: str, expected_sha: str, timeout_seconds: int = 120, poll_interval: float = 1.0) -> Tuple[bool, str]:
    """
    Ждём, пока воркер под контролем Supervisor не станет healthy после рестарта.
    Проверки:
      - локальный /ready возвращает HTTP 200 (через httpx)
      - содержимое target_file имеет sha == expected_sha
    Если успех — вернёт (True, "ok"), иначе (False, message).
    NOTE: Если текущий процесс будет убит Supervisor'ом, код дальше не выполнится. В таком случае Supervisor/Orchestrator
    должен публиковать событие post_restart_healthy в core.event_bus. Эта функция — best-effort проверка в том случае,
    когда вызов рестарта не убивает текущий контрольный поток.
    """
    client = httpx.AsyncClient(timeout=5.0)
    deadline = time.time() + timeout_seconds
    last_err = None
    while time.time() < deadline:
        try:
            # 1) check /ready
            try:
                r = await client.get("http://127.0.0.1:8000/ready")
                if r.status_code == 200:
                    # 2) verify file sha
                    if os.path.exists(target_file):
                        with open(target_file, "rb") as f:
                            content = f.read()
                        actual_sha = hashlib.sha256(content).hexdigest()
                        if actual_sha == expected_sha:
                            await client.aclose()
                            return True, "post-restart validated: ready ok and sha matched"
                        else:
                            last_err = f"sha mismatch: actual={actual_sha} expected={expected_sha}"
                            logger.debug("Waiting: %s", last_err)
                    else:
                        last_err = f"target file {target_file} not found yet"
                        logger.debug("Waiting: %s", last_err)
                else:
                    last_err = f"/ready returned status {r.status_code}"
                    logger.debug("Waiting: %s", last_err)
            except Exception as e:
                last_err = f"HTTP check failed: {e}"
                logger.debug("Waiting: %s", last_err)
        except Exception as e_outer:
            last_err = f"Unexpected error in wait loop: {e_outer}"
            logger.debug("Waiting: %s", last_err)
        await asyncio.sleep(poll_interval)
    try:
        await client.aclose()
    except Exception:
        pass
    return False, f"timeout waiting for post-restart validation: last_err={last_err}"

# =============================================================================
# STARTUP & SHUTDOWN
# =============================================================================
@app.on_event("startup")
async def startup_event():
    global llm_router, agent, deepseek_executor

    # === Step 1: CODE_PATH_MARKER ===
    try:
        from importlib.util import find_spec
        import intelligent_agent as _ia
        agent_path = os.path.realpath(getattr(_ia, "__file__", "") or "")
        app_path = os.path.realpath(__file__)
        logger.info("CODE_PATH_MARKER: app.py = %s", app_path)
        logger.info("CODE_PATH_MARKER: intelligent_agent.py = %s", agent_path)
        spec = find_spec("intelligent_agent")
        if spec and getattr(spec, "origin", None):
            logger.debug("CODE_PATH_MARKER: intelligent_agent.spec.origin = %s", os.path.realpath(spec.origin))
        if not _under_app_root(agent_path):
            logger.error("CRITICAL ERROR: intelligent_agent loaded outside %s ? %s", APP_ROOT_PATH, agent_path)
        if not _under_app_root(app_path):
            logger.error("CRITICAL ERROR: app.py loaded outside %s ? %s", APP_ROOT_PATH, app_path)
    except Exception as e:
        logger.error("CRITICAL ERROR during CODE_PATH_MARKER check: %s", e)

    # Runtime state
    app.state.start_time = datetime.now()
    app.state.analysis_history = []
    app.state.ready = False

    # [IDEMPOTENCY/LOCKS] Инициализация менеджеров
    try:
        app.state.lock_mgr = LockManager()
        logger.info("[LOCKS] LockManager initialized: %s", type(app.state.lock_mgr).__name__)
    except Exception as e:
        logger.warning("[LOCKS] LockManager init failed: %s", e)
        app.state.lock_mgr = None
    try:
        app.state.idempotency_mgr = IdempotencyManager()
        logger.info("[IDEMP] IdempotencyManager initialized: %s", type(app.state.idempotency_mgr).__name__)
    except Exception as e:
        logger.warning("[IDEMP] IdempotencyManager init failed: %s", e)
        app.state.idempotency_mgr = None

    # 1) LLMRouter (Gemini)
    try:
        llm_router = None
        try:
            llm_router = LLMRouter(gemini_api_key=GEMINI_API_KEY, gemini_model_name=GEMINI_MODEL)  # type: ignore[call-arg]
            logger.info("LLMRouter (Gemini) initialized with gemini_api_key/model.")
        except TypeError as te:
            logger.warning("LLMRouter(gemini_api_key=...) unsupported: %s. Try default ctor.", te)
            try:
                llm_router = LLMRouter()  # type: ignore[call-arg]
                logger.info("LLMRouter (Gemini) initialized with default ctor.")
            except Exception as e2:
                logger.warning("LLMRouter default ctor failed: %s. Running without Gemini.", e2)
                llm_router = None
        except Exception as e:
            logger.warning("LLMRouter initialization failed: %s. Running without Gemini.", e)
            llm_router = None
    except Exception as e:
        logger.warning("Outer LLMRouter initialization block failed: %s", e)
        llm_router = None


    # 2) DeepSeekExecutor
    try:
        deepseek_executor = DeepSeekExecutor(api_url=DEEPSEEK_URL, api_key="")
        logger.info("DeepSeekExecutor initialized (url=%s)", DEEPSEEK_URL)
    except Exception as e:
        logger.error("Failed to initialize DeepSeekExecutor: %s", e)
        deepseek_executor = None

    # 3) IntelligentAgent
    try:
        agent = IntelligentAgent(llm_router=llm_router, deepseek_executor=deepseek_executor)
        logger.info("IntelligentAgent initialized successfully")
        app.state.ready = True
    except Exception as e:
        agent = None
        app.state.ready = False
        logger.error("IntelligentAgent initialization failed: %s", e)

    # 4) Events table
    try:
        ensure_events_table()
    except Exception:
        pass

    # 5) CURATOR INIT (S1)
    try:
        app.state.curator = Curator(put_event=put_event, upload_artifact=upload_artifact)
        logger.info("Curator initialized")
    except Exception as e:
        logger.warning("Curator init failed: %s", e)
        app.state.curator = None

    logger.info("Engineer B API fully initialized")

@app.on_event("shutdown")
async def shutdown_event():
    logger.info("Shutting down Engineer B API...")
    if deepseek_executor and getattr(deepseek_executor, "client", None):
        try:
            await deepseek_executor.client.aclose()
            logger.info("DeepSeekExecutor client closed.")
        except Exception as e:
            logger.warning("Error on DeepSeekExecutor client close: %s", e)
    logger.info("Engineer B API shutdown complete")

# =============================================================================
# Основной эндпоинт анализа — патч/деплой
# =============================================================================
@app.post("/agent/analyze")
async def analyze_task(task_data: Dict[str, Any]):
    if not app.state.ready or agent is None:
        raise HTTPException(status_code=503, detail="Agent not ready")

    user_prompt = (task_data or {}).get("task", "").strip()
    job_id = (task_data or {}).get("job_id") or None
    if not user_prompt:
        result = {
            "status": "failed",
            "analysis": "Task prompt was empty, no action taken.",
            "is_complete": False,
            "generated_code": "",
            "report": {"deployment_ready": False, "description": "Empty task", "tests_status": "skipped"},
        }
        return result

    logger.info("Received task: %s", user_prompt[:160])

    async def _try_update_idemp(idemp_key: Optional[str], status: str, result_obj: Dict[str, Any]) -> None:
        mgr = getattr(app.state, "idempotency_mgr", None)
        if not (mgr and idemp_key):
            return
        try:
            await mgr.update_patch_status(idemp_key, status, result_obj)
        except Exception:
            pass

    try:
        analysis_result = await agent.run_cycle(user_prompt)
        logger.debug("Received analysis_result from agent.run_cycle (type %s): %s", type(analysis_result).__name__, analysis_result)

        generated_code: str = ""
        report_data: Dict[str, Any] = {"deployment_ready": False, "description": "No report", "tests_status": "error"}
        analysis_text_for_debug: str = ""

        if isinstance(analysis_result, dict):
            analysis_text_for_debug = analysis_result.get("raw") or ""
        else:
            analysis_text_for_debug = str(analysis_result)

        if isinstance(analysis_result, dict):
            code_field = analysis_result.get("code") or ""
            if code_field:
                generated_code = code_field.strip()
            else:
                generated_code = _extract_code(analysis_text_for_debug)
        else:
            generated_code = _extract_code(analysis_text_for_debug)

        rep = None
        if isinstance(analysis_result, dict):
            rep = analysis_result.get("report")
        if isinstance(rep, dict):
            report_data = rep
        elif isinstance(rep, str):
            report_data = _extract_report_json(rep)
        else:
            report_data = _extract_report_json(analysis_text_for_debug or "")

        logger.debug("Extracted generated_code (first 200 chars): %s", (generated_code[:200] if generated_code else "None"))
        logger.debug("Extracted report_data: %s", report_data)

        agent_status = (analysis_result.get("status") if isinstance(analysis_result, dict) else None) or "error"
        smoke_test_ok = (agent_status in ("ok", "passed", "success"))

        final_status_for_orchestrator = "failed"

        # === PATCH: Step 3 - Call Runtime Smoke Test ===
        target_file = _get_target_filepath(user_prompt)
        runtime_smoke_ok, runtime_smoke_msg = False, "Skipped (no code or agent failed)"
        if smoke_test_ok and generated_code:
            runtime_smoke_ok, runtime_smoke_msg = run_runtime_smoke_test(generated_code, target_file, job_id=job_id)

        idempotency_key: Optional[str] = (task_data or {}).get("idempotency_key")
        if not idempotency_key:
            idempotency_key = generate_idempotency_key(target_file, generated_code or "", user_prompt)

        mgr = getattr(app.state, "idempotency_mgr", None)
        if mgr and idempotency_key:
            try:
                existing = await mgr.get_existing_result(idempotency_key)
            except Exception:
                existing = None
            if existing and isinstance(existing, dict) and "result" in existing:
                logger.info("[IDEMP] Returning cached result for key=%s", idempotency_key[:16])
                return existing["result"]

        if smoke_test_ok and runtime_smoke_ok and generated_code:
            if target_file:
                logger.info("Both smoke tests passed. Attempting to apply changes to: %s", target_file)

                cur = getattr(app.state, "curator", None)
                if cur is None:
                    logger.warning("Curator unavailable; rejecting by policy.")
                    final_status_for_orchestrator = "failed"
                    report_data["description"] = "Curator unavailable."
                    report_data["tests_status"] = "error"
                    report_data["deployment_ready"] = False
                    result = {
                        "status": final_status_for_orchestrator,
                        "analysis": analysis_text_for_debug,
                        "is_complete": False,
                        "generated_code": generated_code,
                        "report": report_data,
                    }
                    await _try_update_idemp(idempotency_key, "failed", result)
                    return result

                review = cur.review(
                    task_text=user_prompt,
                    code=generated_code,
                    target_path=target_file,
                    job_id=job_id,
                    idempotency_key=idempotency_key,
                )
                
                # 🔧 ДОБАВЛЕНО: Атомарное применение кода после успешной проверки Curator
                try:
                    put_event(stage="curator", event_type="curator_review_done",
                              context={"decision": review.get("decision"), "score": review.get("score"), "metrics": review.get("metrics")})
                except Exception:
                    pass

                # === START OF USER'S PATCHED BLOCK ===
                if review.get("approved", False):
                    # NOTE: Original locking logic (LockManager) and SIGHUP/Post-Restart validation 
                    # are intentionally removed in this simplified flow as per patch instruction.
                    logger.info(f"Curator approved. Applying generated_code to target_file: {target_file}")
                    # Using atomic apply directly (without lock wrapper)
                    # === INTEGRATION: Using PatchManager for deployment ===
                    if PATCH_APPLIER_AVAILABLE:
                        success, message, patch_id = apply_code_with_fallback(
                            target_file=target_file,
                            generated_code=generated_code,
                            task_id=job_id,
                            fallback_function=_apply_code_changes
                        )
                        applied_ok = success
                        apply_msg = message
                        backup_path = patch_id  # patch_id вместо backup_path
                    else:
                        applied_ok, apply_msg, backup_path = _apply_code_changes(target_file, generated_code)
                    
                    if applied_ok:
                        logger.info(f"✅ Successfully applied code to {target_file}")
                        
                        # 🔧 Отправка события успешного деплоя (имитация пост-валидации)
                        try:
                            put_event(stage="deploy", event_type="post_deploy_validated", 
                                     context={
                                         "status": "ok", 
                                         "validated_at": datetime.now().isoformat(), 
                                         "target_file": target_file,
                                         "backup_path": backup_path
                                     })
                        except Exception:
                            pass
                        
                        # Обновляем статус для оркестратора (using "passed" for final success status)
                        final_status_for_orchestrator = "passed"
                        report_data["description"] = f"Code successfully applied to {target_file}"
                        report_data["tests_status"] = "passed"
                        report_data["deployment_ready"] = True
                        
                    else:
                        logger.error(f"❌ Failed to apply code to {target_file}: {apply_msg}")
                        final_status_for_orchestrator = "failed"
                        report_data["description"] = f"Application failed: {apply_msg}"
                        report_data["tests_status"] = "error"
                        report_data["deployment_ready"] = False
                else:
                    logger.warning("Curator rejected the changes: %s", review.get("reason", "Unknown"))
                    final_status_for_orchestrator = "failed"
                    report_data["description"] = f"Curator rejected: {review.get('reason', 'Unknown')}"
                    report_data["tests_status"] = "rejected"
                    report_data["deployment_ready"] = False
                # === END OF USER'S PATCHED BLOCK ===


            else:
                logger.info("Both smoke tests passed, but no target file specified. Returning code.")
                final_status_for_orchestrator = "passed"
                report_data.setdefault("description", "Code generated and passed both smoke tests. No file modification requested.")
                report_data["deployment_ready"] = True
                report_data.setdefault("tests_status", "passed")
                report_data["smoke_test_result"] = runtime_smoke_msg

        elif not generated_code:
            logger.warning("No code extracted from agent response.")
            report_data.setdefault("description", "No code extracted from LLM response.")
            final_status_for_orchestrator = "failed"
            report_data["deployment_ready"] = False
            report_data["smoke_test_result"] = "No code extracted"
            try:
                put_event(stage="deploy", event_type="post_deploy_failed", context={"reason": "no_code_extracted"})
            except Exception:
                pass
        else:
            fail_reason = runtime_smoke_msg if not runtime_smoke_ok else report_data.get("smoke_message", "Syntax check failed")
            logger.warning("Smoke test failed. Code not applied. Reason: %s", fail_reason)
            final_status_for_orchestrator = "failed"
            report_data.setdefault("description", f"Smoke test failed: {fail_reason}")
            report_data["deployment_ready"] = False
            report_data["smoke_test_result"] = fail_reason
            try:
                put_event(stage="deploy", event_type="post_deploy_failed", context={"reason": fail_reason})
            except Exception:
                pass

        result = {
            "status": final_status_for_orchestrator,
            "analysis": analysis_text_for_debug or (analysis_result if isinstance(analysis_result, str) else json.dumps(analysis_result, ensure_ascii=False)),
            "is_complete": (final_status_for_orchestrator == "passed") and bool(report_data.get("deployment_ready", False)),
            "generated_code": generated_code,
            "error": None,
            "report": report_data,
        }
        await _try_update_idemp(
            idempotency_key,
            "applied" if result["status"] == "passed" and result["report"].get("deployment_ready") else "failed",
            result,
        )
        return result

    except Exception as e:
        logger.exception("Critical error during agent analysis: %s", e)
        error_report = {
            "deployment_ready": False,
            "description": f"Internal error in analyze_task: {type(e).__name__}: {str(e)}",
            "tests_status": "error",
            "smoke_test_result": f"Internal Error: {type(e).__name__}",
        }
        try:
            put_event(stage="deploy", event_type="incident", context={"severity": "error", "message": str(e)})
        except Exception:
            pass
        result = {
            "status": "error",
            "analysis": f"=== Analysis Report ===\n```json\n{json.dumps(error_report, ensure_ascii=False, indent=2)}\n```",
            "is_complete": False,
            "error": str(e),
            "generated_code": "",
            "report": error_report,
        }
        await _try_update_idemp((task_data or {}).get("idempotency_key"), "failed", result)
        return result

# =============================================================================
# Service endpoints
# =============================================================================
@app.get("/")
async def root():
    return {"message": "Engineer B API is running", "version": "4.0", "status": "operational",
            "endpoints": {"health": "/system/health", "ready": "/ready", "memory": "/agent/memory", "analyze": "/agent/analyze (POST)"}}

@app.get("/system/health")
async def health_check():
    return {"status": "ok", "uptime": str(datetime.now() - app.state.start_time), "llm_router_active": llm_router is not None}

@app.get("/ready")
async def ready():
    if app.state.ready and agent is not None:
        return {"status": "ok"}
    raise HTTPException(status_code=503, detail="Agent not ready")

@app.get("/health")
async def plain_health():
    return {"status": "ok", "ts": datetime.utcnow().isoformat() + "Z"}

@app.get("/agent/memory")
async def get_agent_memory():
    if agent and hasattr(agent, "get_memory"):
        return agent.get_memory()
    raise HTTPException(status_code=503, detail="Agent is not initialized")

# === AutoDev startup marker (safe to keep) ===
try:
    from fastapi import FastAPI, Request as _FastAPI
    _app_obj = globals().get("app", None)
    if isinstance(_app_obj, _FastAPI):
        @_app_obj.on_event("startup")
        async def _autodev_start_marker():
            import logging as _logging
            _logging.getLogger("uvicorn.error").info("EngineerB START [MARK:ENGB-BOOT-1337]")
except Exception:
    pass

# === ENGINEER_B_MARKER ===
try:
    import logging as _lg
    _lg.getLogger("uvicorn.error").info("EngineerB app loaded [MARK:ENGB-BOOT-1337]")
except Exception:
    pass

print("EngineerB app loaded [MARK:ENGB-BOOT-PRINT]")


